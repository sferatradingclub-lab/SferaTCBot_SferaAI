# Архитектура SferaTC Bot

## Обзор системы

SferaTC Bot - это многофункциональный Telegram-бот, построенный на базе современной асинхронной архитектуры с использованием python-telegram-bot и FastAPI.

## Компоненты системы

### 1. Core Layer (Ядро)

#### Main Application (`main.py`)
- Точка входа приложения
- Настройка обработчиков команд и сообщений
- Конфигурация вебхуков и polling режима
- Глобальная обработка ошибок

#### Configuration (`config.py`)
- Управление настройками через переменные окружения
- Валидация конфигурации при запуске
- Кэширование настроек для производительности

### 2. Data Layer (Данные)

#### Models (`models/`)
- **User** - модель пользователя с полями верификации и статусами
- **Base** - базовая модель SQLAlchemy с общими полями
- **CRUD операции** - асинхронные операции с базой данных

#### Database (`db_session.py`, `db_async_session.py`)
- Синхронные и асинхронные сессии базы данных
- Управление подключениями и транзакциями

### 3. Business Logic Layer (Бизнес-логика)

#### Services (`services/`)
- **StateManager** - управление состояниями пользователей (FSM)
- **UserService** - операции с пользователями
- **Notifier** - система уведомлений и рассылок
- **ChatGPTService** - интеграция с OpenRouter API
- **CacheService** - кеширование данных
- **RateLimiter** - ограничение частоты запросов
- **EnhancedErrorHandler** - улучшенная обработка ошибок

#### Handlers (`handlers/`)
Организованы в модули по функциональности:
- **admin/** - административные функции
- **user/** - пользовательские функции
- **common_handlers.py** - общие команды
- **tools_handlers.py** - инструменты трейдинга
- **verification_handlers.py** - верификация пользователей

### 4. Presentation Layer (Представление)

#### Mini App (`mini_app/`)
- Веб-интерфейс для дополнительной функциональности
- Статические файлы (HTML, CSS, JavaScript)
- Интеграция с Telegram Web Apps

## Архитектурные паттерны

### 1. Конечный автомат состояний (FSM)
Используется для управления сложными диалогами пользователей:

```python
class UserState(Enum):
    DEFAULT = auto()
    CHATGPT_ACTIVE = auto()
    SUPPORT_LLM_ACTIVE = auto()
    AWAITING_VERIFICATION_ID = auto()
```

### 2. Dependency Injection
Сервисы передаются через контекст python-telegram-bot:

```python
async def handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    state_manager = StateManager(context)
    user_service = UserService(context)
```

### 3. Repository Pattern
Абстракция доступа к данным через сервисы:

```python
class UserService:
    async def get_user(self, user_id: int) -> Optional[User]:
        # Логика получения пользователя
        pass
```

## Взаимодействие компонентов

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Telegram API   │───▶│   Main App       │───▶│   Database      │
│                 │    │                  │    │                 │
│ - Updates       │    │ - Routing        │    │ - PostgreSQL    │
│ - Webhooks      │    │ - Error Handling │    │ - SQLite        │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Handlers      │    │    Services      │    │   Models        │
│                 │    │                  │    │                 │
│ - Commands      │◀──▶│ - Business Logic │◀──▶│ - Data Access   │
│ - States        │    │ - State Mgmt     │    │ - Validation    │
│ - Validation    │    │ - Caching        │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

## Асинхронность

Проект использует асинхронное программирование на всех уровнях:

- **Асинхронные обработчики** - для параллельной обработки сообщений
- **Асинхронная база данных** - неблокирующие операции с БД
- **Асинхронные HTTP клиенты** - для интеграции с внешними API
- **Job Queue** - для выполнения периодических задач

## Безопасность

### 1. Валидация данных
- Проверка токенов Telegram
- Валидация ID пользователей
- Санитизация ввода

### 2. Rate Limiting
- Ограничение частоты запросов пользователей
- Предотвращение спама и злоупотреблений

### 3. Безопасное логирование
- Исключение чувствительной информации из логов
- Структурированное логирование с уровнями

## Производительность

### 1. Кеширование
- Кеширование часто используемых данных
- Настраиваемое время жизни кеша
- Ограничение размера кеша

### 2. Оптимизация базы данных
- Индексы для часто запрашиваемых полей
- Асинхронные операции
- Connection pooling

### 3. Управление ресурсами
- Корректное закрытие HTTP клиентов
- Освобождение ресурсов при завершении работы
- Мониторинг использования памяти

## Масштабируемость

Проект спроектирован с учетом горизонтального масштабирования:

- **Stateless архитектура** - отсутствие состояния в приложении
- **Внешняя база данных** - разделяемое хранилище данных
- **Конфигурируемые вебхуки** - гибкость развертывания
- **Модульная структура** - возможность независимого масштабирования компонентов

## Мониторинг и отладка

- **Структурированное логирование** - единообразный формат логов
- **Глобальная обработка ошибок** - уведомление администратора о сбоях
- **Метрики и статистика** - отслеживание ключевых показателей
- **Тестирование** - высокий уровень покрытия тестами